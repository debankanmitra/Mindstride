from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from mangum import Mangum
from inference.Initialize import Intialize
from inference.Gemini import Query_from_gemini
from inference.Groq import Query_from_groq


# co, groq, index defined at the module level to store the initialized objects
co = None
groq = None
index = None
@asynccontextmanager
async def lifespan(app: FastAPI):

    # To modify the same global variables we are using the global keyword
    global co, groq, index

    # Modify the global variables
    co, index, groq=await Intialize()
    print("Initialized", co, index, groq)
    yield
    # Clean up 
    print("Cleaned up")


app = FastAPI(lifespan=lifespan)

origins = [
    "http://localhost.tiangolo.com",
    "https://localhost.tiangolo.com",
    "http://localhost:3000",
    "http://localhost:8080",
    "http://localhost:5173",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# handler = Mangum(app, lifespan="off")

# async def generate_event(data):
#     print(data)
#     data=query_from_model(data)
#         # In Python, the yield keyword is used in generator functions to 
#         # define a point at which the function can temporarily suspend its 
#         # execution and yield a value to the caller. When the function encounters a 
#         # yield statement, it returns the yielded value and saves its state. 
#         # The next time the function is called, it resumes execution from where 
#         # it left off, allowing the caller to iterate over the values generated by 
#         # the function one at a time. In the provided code snippet, yield data is 
#         # used to yield the generated event data to the caller.
#     yield f"{json.dumps({'answer': data})}\n\n"
#         # Wait for a second before sending the next event
#         # time.sleep(1)

# @app.post("/events")
# async def get_events(request: Request, response: Response):
#     response.headers["Content-Type"] = "text/event-stream"
#     async for chunk in request.stream():
#         # Read data sent by the client
#         data = chunk.decode()
#         # print(data)
#     # StreamingResponse in FastAPI is a class used to create a streaming HTTP response. 
#     # It's particularly useful when you want to send data to the client continuously, as in the case of 
#     # server-sent events or streaming large files without loading them entirely into memory.
#         res= StreamingResponse(generate_event(data), media_type="text/event-stream")
#         return res





class UserQuery(BaseModel):
    user: str


@app.post("/groq_inference")
async def get_groq_inference(query: UserQuery):
    response = Query_from_groq(query.user, co, groq, index)
    return {"output": response}

@app.post("/gemini_inference")
async def get_gemini_inference(query: UserQuery):
    # sending modified co, index directly with the user query
    response = Query_from_gemini(query.user, co, index)
    return {"output": response}


# Create the Mangum handler
handler = Mangum(app)